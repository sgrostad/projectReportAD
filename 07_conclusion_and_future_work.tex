\chapter{Conclusion and Future Work}
\label{ch:Conclusion}
This thesis has investigated the possibility of using the new programming language, Julia, as a language both for implementing prototypes of new oil reservoir simulators, as well as building efficient industrial simulators. 

The process of creating an industrial simulator usually consist of first creating a prototype that is further developed to be an industrial simulator. In SINTEF's approach, the prototype and the finished simulator is implemented in two different languages; A high-level scripting language for the prototype and a lower-level compiled language for the finished simulator. The possibility of performing the whole implementation process in Julia may contribute to increase the efficiency of developing new computational tools significantly.

To investigate this, the thesis has looked further into solving PDEs that describe flow in porous media, using AD and a finite-volume method. The PDEs are solved by discretizing the divergence and gradient operators such that the discrete equations can be implemented very similar to the continuous. By setting up the equations as a vector function on residual form, the system can be solved using AD to obtain the Jacobian of the system and the Newton--Raphson method to find the roots of the function. The focus of the thesis has been to look at the performance of the AD tools. Three new AD implementations in Julia have been presented and compared to a third-party implementation in Julia and AD tools from MRST. 

The AD libraries are benchmarked against each other in a prototype of a single-phase flow solver, simulating primary production from a reservoir with one well producing oil. The third-party implementation of AD, with its dense matrix structure, proved useless for calculating the sparse Jacobians that correspond to the residual function. For this simulation, it is more than 30 times slower than the other AD tools and it is not further considered after this result. The first two implementations in Julia are called \texttt{ForwardAutoDiff}(\texttt{FAD}) and \texttt{CustomJacobianAutoDiff}(\texttt{CJAD}). These are high-level AD tools that are easy to use and that are based on the implementation in MRST. \texttt{CJAD} is an extension of \texttt{FAD}, where \texttt{FAD} only uses sparse matrix structure for its Jacobians, \texttt{CJAD} makes optimized calculations when the Jacobian is a diagonal-, identity-, or null matrix. For the single-phase simulation \texttt{CJAD} and MRST perform similar, while \texttt{FAD} is approximately twice as slow. 

The last AD tool in Julia is called local AD and is implemented as a motivation from the properties of the single-phase simulation as well as how AD is implemented in OPM. Hence, local AD is a lower-level implementation than \texttt{FAD} and \texttt{CJAD}, and since OPM is the tool SINTEF recommends for creating efficient industrial simulators, it is expected that this will give an improved performance. For the single-phase solver, local AD is approximately six times faster than \texttt{CJAD} and MRST. To further test the abilities of local AD in Julia, a second simulator is implemented. This is a two-phase solver, simulating the flow of water, in a single layer of the SPE10 model 2 reservoir, when injecting water into the centre of the reservoir. For this simulation, \texttt{CJAD} and MRST continue to deliver equal performances, while the local AD method is approximately five times faster.

The implementation and benchmarks of \texttt{CJAD} indicate that Julia is well suited for making quick prototypes of simulators, and the benchmarks of local AD give good indications that it also could be possible to create efficient industrial simulators for oil recovery. However, the local AD implementation has only been tested for a grid with less than 15,000 cells and not on a full realistic simulation model. As a reference, the full SPE10 model 2 grid has 1,122,000 cells. A natural next step in testing Julia is to make an implementation like local AD in MATLAB and compare the two languages. Since local AD depends on fast execution of for-loops, it is not expected that MATLAB will manage to execute local AD efficient, but it is a good test to see if Julia actually is a step forward compared to MATLAB. As mentioned in \autoref{sec:parallelComputing}, macro functions to parallelize for-loops are under development in Julia. This is easy to add into the functions that assemble the equations in local AD and it has been attempted, but the macro functions are at the moment too unstable. When these functions become more stable, it will be interesting to see if, and possibly by how much, this can improve the current implementation. A final investigation will be to confirm whether Julia can match the computational efficiency of OPM, or other industrial simulators, in a full-scale realistic simulation. 

