\chapter{Conclusion and Further Work}
\label{ch:Conclusion}
This thesis has investigated the possibility of using the new programming language, Julia, as a language both for implementing prototypes of new oil reservoir simulators, as well as building efficient industrial simulators. 

The process of creating an industrial simulator usually consists of first creating a prototype and subsequently developing a more comprehensive industrial simulator based on the prototype model. SINTEF's approach is to implement the prototype and the finished simulator in two different languages: a high-level scripting language for the prototype, and a lower-level compiled language for the industrial simulator. The possibility of performing the entire implementation in Julia may contribute to significantly increase the efficiency of developing new computational tools.

To investigate this, the thesis has explored solving PDEs that describe flow in porous media, using AD and a finite-volume method. The PDEs are solved by discretizing the gradient- and divergence operator so that the discrete equations can be implemented in almost the same form as the continuous formulas. By setting up the equations as a vector function in residual form, the system can be solved using AD to obtain the Jacobian of the system and the Newton--Raphson method to find the roots of the function. The focus of the thesis has been to examine the performance of the AD tools. Three new AD implementations in Julia have been presented and compared to a third-party implementation in Julia and AD tools from MRST. 

The AD libraries were benchmarked against each other in a prototype of a single-phase flow solver, simulating primary production from a reservoir with a single well producing oil. The third-party implementation of AD in Julia, with its dense matrix structure, proved ineffective for calculating the sparse Jacobians corresponding to the residual functions. For this simulation, it was more than 30 times slower than the other AD tools and was eliminated for further consideration. The first two implementations in Julia are called \texttt{ForwardAutoDiff}(\texttt{FAD}) and \texttt{CustomJacobianAutoDiff}(\texttt{CJAD}). These are high-level AD tools that are easy to use and that are based on the implementation in MRST. \texttt{CJAD} is an extension of \texttt{FAD}, where \texttt{FAD} only uses sparse matrix structure for its Jacobians, \texttt{CJAD} makes optimized calculations when the Jacobian is a diagonal-, identity-, or null matrix. For the single-phase simulation, \texttt{CJAD} and MRST performed similarly, while \texttt{FAD} was approximately twice as slow. 

The last AD tool in Julia is called local AD and was implemented motivated by the properties of the single-phase simulation, as well as the way AD is implemented in OPM. Hence, local AD is a lower-level implementation than \texttt{FAD} and \texttt{CJAD}, and since OPM is the tool SINTEF recommends for creating efficient industrial simulators, it was expected that this would offer an improved performance. For the single-phase solver, local AD was indeed approximately six times faster than \texttt{CJAD} and MRST. To further test the capabilities of local AD in Julia, a second simulator was implemented. This was a two-phase solver, simulating the flow of water in a single layer of the SPE10 Model 2 reservoir, when injecting water into the center of the reservoir. For this simulation, \texttt{CJAD} and MRST continue to exhibit similar performance, while the local AD method was approximately five times faster.

The implementation and benchmarks of \texttt{CJAD} indicate that Julia is well suited for making quick prototypes of simulators, and the benchmarks of local AD provide good indications that it may also be possible to create efficient industrial simulators for oil recovery. However, the local AD implementation has only been tested on a grid with less than 15,000 cells and not on a fully realistic simulation model. As a point of reference, the full SPE10 Model 2 grid has 1,122,000 cells. A natural next step in testing Julia is to make an implementation in MATLAB, similar to local AD, and compare the two languages. Since local AD depends on fast execution of for-loops, it is not expected that MATLAB will manage to execute local AD efficiently, but it is a good test to see if Julia actually is a step forward compared to MATLAB. 

Macro functions to parallelize for-loops are currently under development in Julia. It would be easy to insert these into the functions that assemble the equations in local AD. This has already been attempted, but the macro functions are too unstable at the moment. When these functions become more stable, it will be interesting to see if, and possibly by how much, this can improve the current implementation. A final investigation will necessarily be to confirm whether Julia can match the computational efficiency of OPM or other industrial simulators in a full-scale realistic simulation. 

