\chapter{Introduction}
\section{Automatic Differentiation}
Automatic differentiation (AD) is a method that automatically calculates the derivatives of a function with no human calculations. It is, however, not the method of finite differences, nor symbolic differentiation. The method consists of separating an expression into a finite set of elementary operations, +,-,* and /, and elementary functions like the exponential and the logarithm. It then performs standard differentiation rules to these operations and functions. However, unlike how we calculate derivatives by hand, it does not apply differentiation rules to the symbols; It carries along both the function value and the derivative values for all the elementary steps of the evaluation. In this way it can calculate the next function- and derivative value, based on the current values and the rules for the next elementary operation or function. This gives derivative values as accurate as hand derived derivatives, but without possible human errors and with low computational cost. AD can be split into two different methods -- backward AD and forward AD. They both obtain the derivatives, but with different approaches that have different capabilities. The exact difference and capabilities between the two will be discussed closer in \autoref{sec:AD}. 

According to \emph{\cite{SurveyAD}} the first ideas of the concept AD dates back to the 1950's \emph{\citep{nolan1953analytical, beda1959programs}}. More specifically, forward AD was discovered by Wengert in 1964 \emph{\citep{wengert1964simple}}. It is more difficult to date exactly when backward AD was discovered, but the first article containing the essence of backward AD dates back to the 1960's \emph{\citep{boltyanskii1960theory}}. After the initial discovery of AD, further activities hibernated for a couple of years, before it was rediscovered along with the birth of modern computers and computer languages. The first running computer program that used backward AD, and automatically computed the derivatives, came in 1980 by Speelpenning \emph{\citep{speelpenning1980compiling}}. Further research on the topic was done by among others Griewank during the 1980's \emph{\citep{griewank1989automatic}}. Today AD is widely used in many applications. One of them is machine learning that specifically uses the backward AD method to minimize functions. 

This thesis' main focus is to use the forward AD method to solve partial differential equations(PDEs), using the new programming language Julia. More specifically, solving PDEs that describe flow in porous media. Simulation of flow in porous media can refer to many things. Some examples are modelling the movement of groundwater reserves, storage of $CO_2$ gases to reduce our environmental footprint and oil reservoir simulations to maximize the amount of oil we can recover from a reservoir. All these are examples of flow under the surface of the earth. But simulation of flow in porous media can also be used for simulation of flow inside batteries, fuel cells, textiles, for water purifying and even to describe processes inside our human bodies. However, this thesis will solely look at using AD to solve PDEs that describe flow in oil reservoirs.

\section{Oil Reservoirs}
In the book, \textit{An Introduction to Reservoir Simulation Using MATLAB/GNU Octave}, by \emph{\citet{lieMrstUrl}}, Lie has an thorough review of the properties of an oil reservoir and how we can use numerical simulations to simulate oil recovery. I will not go as deep into the subject, as it is outside of scope for this thesis, but I will give a smaller introduction to the topic, making it clear why it is interesting to use the new programming language Julia, to solve these PDEs using AD.

Lie uses an analogue to explain the properties of an oil reservoir. A simplified model of a typical oil reservoir can be compared to a rigid sponge fully soaked in oil. This sponge is under high pressure and with solid walls on all sides such that there is no way for the oil to escape. In reality the oil lies in between sand and mineral particles that behaves like a porous medium with the ability to transmit fluids. If we drill a hole in one of the solid walls and create a well, given that the pressure inside the sponge is high enough, the oil will flow out of this well and the pressure inside the sponge will be reduced. In oil recovery this is called the primary production. In primary production the reservoir does all the work and the oil floats out on its own. For normal oil reservoirs, primary production will extract about 30\% of the oil in the reservoir. To extract more, we have to apply external pressure to the reservoir. One out of many methods to do this, is to pump salt water into the reservoir through injectors. By doing this we increase the pressure close to the injector and push the oil towards the wells. This is called secondary production. According to Lie, the average percentage of oil extracted from oil reservoirs on the Norwegian Continental Shelf is about 50\%. This means it is a lot of oil we are not able to extract! An increase in the amount we are able to extract will not only be economically beneficial for the owners of the reservoir, but it can also help avoiding exploration for new oil reservoirs in more vulnerable areas. This is why it is so important to be able to simulate the flow inside oil reservoirs. If we can find optimal and better methods to recover more oil from each reservoir, it can make a huge impact both financially and environmentally.

\section{Creating a Simulator}
The process of making a new simulator for oil reservoir simulations, is normally started by creating a prototype. The prototype is made quickly, often in a high-level programming language, to demonstrate what the finished product will do. This is usually for a smaller reservoir as the prototype will not handle the full extent of a full reservoir simulation. After the prototype phase, performance improvements and further implementations are needed before the actual simulator is ready to perform the simulation on the full reservoir. The Computational Geosciences group in the department of Mathematics and Cybernetics at SINTEF Digital has created the MATLAB Reservoir Simulation Toolbox (MRST) \emph{\citep{mrstHomepage}} for the  purpose of prototyping. According to MRST's homepage, "MRST is not primarily a simulator, but is mainly intended as a toolbox for rapid prototyping and demonstration of new simulation methods and modelling concepts." Although most of the tools and simulators in MRST are very efficient and perform well -- if you are to simulate more heavy simulation, they recommend to use the Open Porous Media (OPM) Flow simulator \emph{\citep{OPM}}. OPM is a toolbox to build simulations of porous media processes that are mainly written in C++ and C. 

This is where the problem with the building process of a numerical simulator lie. MATLAB is a high-level language that is perfect to quickly make prototypes and demonstrations because of its easy to use mathematical syntax. It is, however, not possible to use for the final simulator, as it is not computational efficient enough. Instead we have to implement the final simulator in a lower-level language, like C or C++, which is more computational efficient. C and C++ are not built for numerical analysis, hence it will take longer time to create the simulator. In addition, by first creating a prototype in one language, and then the simulator in another, there will be a lot of code from the prototype that is unusable in the final simulator. This will lead to writing code twice, which is inefficient. It is possible to call, for example, C++ code from MATLAB, but this can often be tricky and there are many difficulties to make the languages speak together properly. This may lead to unstable code and is not an optimal solution. 

This is where the new programming language Julia comes in. Julia is a language built from scratch, with focus on mathematical programming. It is meant to be a language as familiar as MATLAB in terms of mathematical notations, but as fast as C in terms of computational speed. If they have managed to do this, it will be possible, in one single language, to create prototypes and demonstrations and then further develop the existing code into efficient simulators. This could drastically increase the efficiency of creating a simulator, not only for oil reservoirs, but for any other type of simulator. 

\section{Outline of Thesis}
The thesis will discuss whether Julia is a language that can be used to implement both prototypes and efficient industrial simulators for flow in oil reservoirs. More specifically it will look at how well Julia performs when implementing AD and using it in oil reservoir simulations. The thesis begins with describing the theory behind AD and the difference between backward and forward AD in \autoref{ch:theory}. The chapter continues describing different applications of AD and how we can use forward AD to elegantly solve partial differential equations using a finite volume method and a discretization of the differentiation operators. The history of Julia and the reasons why it is supposed to be as fast as C, but as convenient as MATLAB, will be discussed in \autoref{ch:Julia}. Implementation specific parts, concerning implementing AD in Julia, are discussed in \autoref{ch:Implementation}. It will describe two implementations and test them against a third-party AD implementation in Julia and implementations from MRST in MATLAB. The implemented AD libraries will then be used in \autoref{ch:FlowSolver} to test the performance in a prototype simulator from MRST simulating a primary production. Motivated by the results and the characteristics of the problem in \autoref{ch:FlowSolver}, \autoref{ch:LocalAD} describes another implementation of AD in Julia and test this new AD tool against the previous tools in a simulation simulating a secondary production. Lastly, \autoref{ch:Conclusion} summarizes the results and analyze how Julia perform. It also mentions what this thesis has not tested, that are interesting to look further into.