\chapter{Introduction}
\section{Automatic Differentiation}
Automatic differentiation (AD) is a computational method that automatically calculates exact values for the derivatives of a function. It is, however, not the method of finite differences, nor symbolic differentiation. The method consists of separating an expression into a finite set of elementary operations: $+$,$-$,$*$,$/$, and elementary functions like the exponential and the logarithm. It then applies standard differentiation rules to these operations and functions. However, unlike the way we calculate derivatives by hand, it does not apply differentiation rules to the symbols. Instead, it proceeds with both the function- and the derivative values for all the elementary steps of the evaluation. This way, it can calculate the next function- and derivative values, based on the current values and the rules for the next elementary operation or function. This yields derivative values that, up to roundoff errors, are as accurate as manually computed derivatives, but without potential human errors and with low computational cost. AD can be split into two different methods: backward AD and forward AD. They both obtain the derivatives, but with different approaches, each having different capabilities. The exact difference and capabilities between the two will be discussed closer in \autoref{sec:AD}. 

According to \emph{\cite{SurveyAD}}, the first ideas of the AD concept emerged in the 1950s \emph{\citep{nolan1953analytical, beda1959programs}}. More specifically, forward AD was then discovered by \emph{\citet{wengert1964simple}}. It is more difficult to date exactly when backward AD was discovered, but the first article containing the essence of backward AD dates back to the 1960s \emph{\citep{boltyanskii1960theory}}. After the initial discovery of forward and backward AD, no significant activities took place for a couple of years, before the method was rediscovered along with the birth of modern computers and computer languages. The first running computer program that used backward AD, and automatically computed the derivatives, arrived in 1980 developed by \emph{\citet{speelpenning1980compiling}}. Further research on the topic was done by, among others, \emph{\citet{griewank1989automatic}}. Today, AD is widely used in many applications. One of them is machine learning that specifically uses the backward AD method to minimize functions. 

\section{Objective of the Thesis}
The primary focus of this thesis is to use the forward AD method to solve Partial Differential Equations (PDEs), using the new programming language Julia; and more specifically, solve PDEs that describe flow in porous media. The objective is to figure out whether Julia can be used as a language both for rapid prototyping as well as building efficient industrial simulators. 

Simulation of flow in porous media can be used in several applications. Examples include modelling the movement of groundwater reserves, subsurface storage of CO$_2$ to reduce environmental footprint, and reservoir simulations to maximize the amount of hydrocarbons that can be recovered from a reservoir. All these are examples of flow below the surface of the earth, but simulation of flow in porous media can also be used to understand flow inside batteries, fuel cells, textiles, for water purification, and even to describe processes inside our human bodies. However, this thesis will solely look at using AD to simulate flow in oil reservoirs.

\section{Oil Reservoirs}
\label{sec:OilReservoirs}
The textbook, \textit{An Introduction to Reservoir Simulation Using MATLAB/GNU Octave}, by \emph{\citet{lieMrstUrl}}, offers a thorough review of the properties of an oil reservoir and how numerical simulations can be used to understand oil recovery processes. I will not provide a comprehensive review of the subject, as it is outside the scope of this thesis, but I will give a brief introduction to the topic, explaining why it is of interest to use the new programming language Julia to solve these PDEs using AD.

Lie uses an analogy to explain the properties of an oil reservoir. A simplified model of a typical oil reservoir can be compared to a rigid sponge completely soaked in oil. The sponge is compressed with solid walls on all sides, preventing any oil from escaping. In reality, oil lies in between tightly compacted sand and mineral particles that constitute a porous medium with the ability to transmit fluids. 

If we drill a hole in one of the solid walls surrounding the sponge to create a well, and provided that the pressure is high enough, the oil will flow out of the well while the pressure inside the sponge will decline. In oil recovery, this is called the primary production, during which the reservoir does all the work and the oil floats out on its own. For most oil reservoirs, primary production will extract up to 30\% of the oil in the reservoir. To extract more, we have to apply external pressure to the reservoir. One of many methods is to pump salt or fresh water into the reservoir through injectors. This increases the pressure close to the injector and push the oil towards the wells. This is called secondary production. According to \citep{lieMrstUrl}, the average percentage of oil extracted from oil reservoirs on the Norwegian Continental Shelf is approximately 50\%. This means there is still a large quantity of oil we are not able to extract. An increase in the amount we are able to extract will not only be economically beneficial for the owners of the reservoir, but it can also help avoiding exploration for new oil reservoirs in more vulnerable areas. This is why it is so important to be able to simulate the flow inside oil reservoirs. If we can find optimal and better methods to recover more oil from each reservoir, it can make a huge impact both financially and environmentally.

\section{Creating a Simulator}
The process of making new simulators for oil reservoir modelling, is typically started by creating a prototype. The prototype is implemented quickly, and in some cases by using a high-level programming language, to illustrate what the finished product will do. This is usually applied to a simplified and conceptual reservoir model, since such prototypes rarely can handle the full extent of a complete reservoir simulation. After the prototype phase, performance improvements and further implementations are needed before the actual simulator is ready to perform the simulation on the full reservoir. The Computational Geosciences group at the department of Mathematics and Cybernetics at SINTEF Digital has created the MATLAB Reservoir Simulation Toolbox (MRST) \emph{\citep{mrstHomepage}} for the  purpose of prototyping. According to MRST's homepage, \enquote{MRST is not primarily a simulator, but is mainly intended as a toolbox for rapid prototyping and demonstration of new simulation methods and modelling concepts.} Most of the tools and simulators in MRST are surprisingly efficient and perform well, even for medium-sized models of real reservoirs. However, for more extensive simulations, the Computational Geoscience group recommend using the Open Porous Media (OPM) Flow Simulator \emph{\citep{opm}}. OPM is a toolbox to build simulations of porous media processes which is mainly written in C and C++. 

This is where the problem with the building process of a numerical simulator arises. MATLAB is a high-level language perfect for quickly making prototypes and demonstrations because of its easy-to-use mathematical syntax. However, it is not ideal for a final simulator, because it is not computationally efficient enough. Instead, we have to implement the final simulator in a lower-level language that is more computationally efficient, such as C or C++. But, these type of languages are not designed for numerical analysis, hence it usually takes longer time and more programming effort to create the simulator. Experience shows that the development time is usually reduced if a prototype is initially created in a high-level scripting language, and then a full-featured simulator is reimplemented in a compiled language. The disadvantage of this approach is that only a small amount of the code from the prototype can be used in the final simulator. It is possible to call, for example, C++ code from MATLAB, but it is difficult to make the languages interact properly. This may lead to unstable code and is not an optimal solution. The ideal solution would be a language that supports high-level scripting for rapid prototyping and at the same time offers the full computational efficiency of a compiled language.

This is where the new programming language Julia comes into play. Julia is a language built from scratch, with focus on mathematical programming. It is meant to be a language as familiar as MATLAB in terms of mathematical notations, but as fast as C in terms of computational speed. If the developers have managed to do this, it will be possible to create prototypes and then further develop the existing code into high-performing simulators, in one single language. This could drastically increase the efficiency of creating simulators, not only for oil reservoirs, but for many other applications. 

\section{Outline of Thesis}
The thesis investigates whether Julia is a language that can be used to implement both prototypes and efficient industrial simulators for flow in oil reservoirs. More specifically, it examines how Julia performs when implementing AD and using it in oil reservoir simulations. In \autoref{ch:theory}, the thesis describes the theory behind AD and the difference between backward and forward AD. The chapter continues by presenting different applications of AD and how 
forward AD can be used to elegantly solve PDEs using a finite-volume method and a discretization of the differentiation operators. The history of Julia, and why it is presumed to be as fast as C, but as convenient as MATLAB, is discussed in \autoref{ch:Julia}. Implementation-specific parts, concerning how high-performing AD tools can be developed in Julia, is presented in \autoref{ch:Implementation}. It further describes two implementations and tests them against a third-party AD-tool in Julia and implementations from MRST. The implemented AD libraries will then be used in \autoref{ch:FlowSolver} to benchmark the performance in a prototype simulator from MRST, simulating primary production. Motivated by the results and the characteristics of the problem in \autoref{ch:FlowSolver}, \autoref{ch:LocalAD} describes another implementation of AD in Julia and benchmarks this new AD tool against the previous tools for simulating secondary production. Lastly, \autoref{ch:Conclusion} provides a summary of the results and a performance review of Julia. It also describes conditions and areas not tested in this thesis, and outlines problems and challenges that warrants further inquiry.