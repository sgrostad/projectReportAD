\chapter{Introduction}
\section{Automatic Differentiation}
Automatic differentiation (AD) is a method that automatically calculates exact values for the derivatives of a function with no human calculations. It is, however, not the method of finite differences, nor symbolic differentiation. The method consists of separating an expression into a finite set of elementary operations, +,-,* and /, and elementary functions like the exponential and the logarithm. It then performs standard differentiation rules to these operations and functions. However, unlike how we calculate derivatives by hand, it does not apply differentiation rules to the symbols; instead, it carries along both the function value and the derivative values for all the elementary steps of the evaluation. In this way, it can calculate the next function- and derivative value, based on the current values and the rules for the next elementary operation or function. This gives derivative values that, up to roundoff errors, are as accurate as hand computed derivatives, but without possible human errors and with low computational cost. AD can be split into two different methods -- backward AD and forward AD. They both obtain the derivatives, but with different approaches that have different capabilities. The exact difference and capabilities between the two will be discussed closer in \autoref{sec:AD}. 

According to \emph{\cite{SurveyAD}}, the first ideas of the AD concept date back to the 1950s \emph{\citep{nolan1953analytical, beda1959programs}}. More specifically, forward AD was discovered by \emph{\citet{wengert1964simple}}. It is more difficult to date exactly when backward AD was discovered, but the first article containing the essence of backward AD dates back to the 1960s \emph{\citep{boltyanskii1960theory}}. After the initial discovery of AD, further activities hibernated for a couple of years, before the method was rediscovered along with the birth of modern computers and computer languages. The first running computer program that used backward AD, and automatically computed the derivatives, came in 1980 by \emph{\citet{speelpenning1980compiling}}. Further research on the topic was done by, among others, \emph{\citet{griewank1989automatic}}. Today, AD is widely used in many applications. One of them is machine learning that specifically uses the backward AD method to minimize functions. 

\section{Goal of the Thesis}
This thesis' main focus is to use the forward AD method to solve partial differential equations(PDEs), using the new programming language Julia; and more specifically, solve PDEs that describe flow in porous media. Simulation of flow in porous media can be refer to several applications. Examples include modelling the movement of groundwater reserves, subsurface storage of CO$_2$ to reduce our environmental footprint, and reservoir simulations to maximize the amount of hydrocarbons we can recover from a reservoir. All these are examples of flow under the surface of the earth, but simulation of flow in porous media can also be used to understand flow inside batteries, fuel cells and textiles, for water purifying, and even to describe processes inside our human bodies. However, this thesis will solely look at using AD to simulate flow in oil reservoirs.

\section{Oil Reservoirs}
\label{sec:OilReservoirs}
The textbook, \textit{An Introduction to Reservoir Simulation Using MATLAB/GNU Octave}, by \emph{\citet{lieMrstUrl}}, has a thorough review of the properties of an oil reservoir and how we can use numerical simulations to understand oil recovery processes. I will not go as deep into the subject, as it is outside of the scope for this thesis, but I will give a brief introduction to the topic, making it clear why it is interesting to use the new programming language Julia to solve these PDEs using AD.

Lie uses an analogue to explain the properties of an oil reservoir. A simplified model of a typical oil reservoir can be compared to a rigid sponge fully soaked in oil. This sponge is under high pressure and with solid walls on all sides such that there is no way for the oil to escape. In reality, the oil lies in between tightly compacted sand and mineral particles that constitute a porous medium with the ability to transmit fluids. If we drill a hole in one of the solid walls and create a well, and if the pressure inside the sponge is high enough, the oil will flow out of this well and the pressure inside the sponge will be reduced. In oil recovery, this is called the primary production, during which the reservoir does all the work and the oil floats out on its own. For most oil reservoirs, primary production will extract up to 30\% of the oil in the reservoir. To extract more, we have to apply external pressure to the reservoir. One out of many methods to do this, is to pump salt or fresh water into the reservoir through injectors. By doing so, we increase the pressure close to the injector and push the oil towards the wells. This is called secondary production. According to \citep{lieMrstUrl}, the average percentage of oil extracted from oil reservoirs on the Norwegian Continental Shelf is approximately 50\%. This means that there is still a lot of oil we are not able to extract! An increase in the amount we are able to extract will not only be economically beneficial for the owners of the reservoir, but it can also help avoiding exploration for new oil reservoirs in more vulnerable areas. This is why it is so important to be able to simulate the flow inside oil reservoirs. If we can find optimal and better methods to recover more oil from each reservoir, it can make a huge impact both financially and environmentally.

\section{Creating a Simulator}
The process of making a new simulator for oil reservoir simulations, is normally started by creating a prototype. The prototype is made quickly, and in some cases in a high-level programming language, to demonstrate what the finished product will do. This is usually applied to a simplified and conceptual reservoir model, as such prototypes rarely can handle the full extent of a full reservoir simulation. After the prototype phase, performance improvements and further implementations are needed before the actual simulator is ready to perform the simulation on the full reservoir. The Computational Geosciences group in the department of Mathematics and Cybernetics at SINTEF Digital has created the MATLAB Reservoir Simulation Toolbox (MRST) \emph{\citep{mrstHomepage}} for the  purpose of prototyping. According to MRST's homepage, \textit{"MRST is not primarily a simulator, but is mainly intended as a toolbox for rapid prototyping and demonstration of new simulation methods and modelling concepts."} Most of the tools and simulators in MRST are surprisingly efficient and perform well, even for medium-sized models of real reservoirs, but if you are to simulate more heavy simulation, they recommend to use the Open Porous Media (OPM) Flow simulator \emph{\citep{opm}}. OPM is a toolbox to build simulations of porous media processes that are mainly written in C and C++. 

This is where the problem with the building process of a numerical simulator lie. MATLAB is a high-level language that is perfect to quickly make prototypes and demonstrations because of its easy-to-use mathematical syntax. It is, however, not likely to be used for the final simulator, as it is not computational efficient enough. Instead, we have to implement the final simulator in a lower-level language, like C or C++, that is more computational efficient. C and C++ are not built for numerical analysis, hence it usually takes longer time and more programming effort to create the simulator. Experience shows that the development time is usually reduced if one first creates a prototype in a high-level scripting language, and then reimplements a full-featured simulator in a compiled language. The obvious disadvantage of this approach is that there will be a lot of code from the prototype that is unusable in the final simulator. It is possible to call, for example, C++ code from MATLAB, but this can often be tricky and there are many difficulties to make the languages speak together properly. This may lead to unstable code and is not an optimal solution. Ideally, one should have used a language that supports high-level scripting for rapid prototyping and at the same time offers the full computational efficiency of a compiled language.

This is where the new programming language Julia comes in. Julia is a language built from scratch, with focus on mathematical programming. It is meant to be a language as familiar as MATLAB in terms of mathematical notations, but as fast as C in terms of computational speed. If the developers have managed to do this, it will be possible, in one single language, to create prototypes and demonstrations and then further develop the existing code into high-performing simulators. This could drastically increase the efficiency of creating a simulator, not only for oil reservoirs, but for any other applications. 

\section{Outline of Thesis}
The thesis will investigate whether Julia is a language that can be used to implement both prototypes and efficient industrial simulators for flow in oil reservoirs. More specifically, it will look at how Julia performs when implementing AD and using it in oil reservoir simulations. The thesis begins by describing the theory behind AD and the difference between backward and forward AD in \autoref{ch:theory}. The chapter continues describing different applications of AD and how we can use forward AD to elegantly solve partial differential equations using a finite-volume method and a discretization of the differentiation operators. The history of Julia, and the reasons why it is supposed to be as fast as C, but as convenient as MATLAB, will be discussed in \autoref{ch:Julia}. Implementation-specific parts, concerning how one can develop high-performing AD tools in Julia, are discussed in \autoref{ch:Implementation}. It will describe two implementations and test them against a third-party AD implementation in Julia and implementations from MRST in MATLAB. The implemented AD libraries will then be used in \autoref{ch:FlowSolver} to test the performance in a prototype simulator from MRST, simulating primary production. Motivated by the results and the characteristics of the problem in \autoref{ch:FlowSolver}, \autoref{ch:LocalAD} describes another implementation of AD in Julia and tests this new AD tool against the previous tools for simulating secondary production. Lastly, \autoref{ch:Conclusion} summarizes the results and analyzes how Julia performs. It also mentions what this thesis has not tested, and outlines problems and challenges that are interesting to look further into.