\chapter{Local Automatic Differentiation}
\label{ch:LocalAD}
This chapter will consider a different approach on how to use AD to solve PDEs. When solving PDEs using a finite element method each cell will only depend on the neighbouring cells. In the \texttt{FAD} and \texttt{CJAD} implementations, the dependencies are stored in the discrete gradient and divergence operators. The implementation of \texttt{FAD} and \texttt{CJAD} calculates the residual function value and corresponding Jacobian for the whole grid simultaneously by having a vector to store the values and sparse matrices for the Jacobians. Hence when the discrete gradient and divergence operators are used in the calculation of the residual function in \autoref{ch:FlowSolver}, the Jacobian are automatically obtained with the structure seen in \autoref{fig:flowSolverJacobian}. However, this structure is known from the grid properties given in the \texttt{G} variable. So instead of calculating the residual function for all cells at once, the new approach takes one cell at the time and sums up the contributions from each neighbour. This is done for each cell until all the residual functions for each cell is calculated. This new approach is called local AD and the method is based on the same idea as how AD is done in OPM \emph{\citep{OPM}}. Since OPM is written in C and C++ it is interesting to see if you can write similar type of code in Julia and obtain the same computational efficiency. \todo{Må teste noe mot dette og kommentere for at dette skal kunne stå der}

\section{Implementation}
To get a better understanding of how Local AD works, it is best to look at how it is implemented. Like for \texttt{FAD} and \texttt{CJAD} I have implemented local AD using a struct I have called \texttt{LAD}.
\lstinputlisting{code/LAD_structSimple.jl}
Since we now only operate on one cell at the time the implementation of Local AD is simpler than for \texttt{FAD} and \texttt{CJAD}. The value of the AD-variable is now only a scalar and the Jacobian matrices is replaced by a vector of derivatives. For the single phase flow solver in \autoref{ch:FlowSolver}, the vector will be of length one, as each cell only contain one variable (pressure). The implementation is however with \texttt{derivatives} as a vector. This is for the opportunity to implement more complex simulations like a two or three phase simulation where each cell can contain water, oil and/or gas. The implementation of operators for the \texttt{LAD} struct is done similar as explained in \autoref{ch:Implementation} for \texttt{FAD} and \texttt{CJAD}, but since we only have a vector of derivatives instead of a Jacobian matrix, the implementation is easier and follows the lines of the description from \autoref{sec:FADWithMultipleParameters}. 

Where the implementation of the Local AD tool is easier than for \texttt{FAD} and \texttt{CJAD}, there is more work when creating the simulation. Since we do not use discrete gradient and divergence operators, but traverse through the grid cell by cell, we need somewhere to store the resulting values of the residual function. We also need a method to traverse through all the cells and to calculate the contributions from each neighbouring cell. This is where it becomes clear that when we use local AD to create the simulation it becomes a more application specific implementation than the method for \texttt{FAD} and \texttt{CJAD}. To create the flow solver from \autoref{ch:FlowSolver} I have chosen to store the calculated residual values in another struct called \texttt{FlowSystems}:
\




\todo[inline]{Se på parallellisering for lokal AD?}